<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>刘鹏的小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我想起那天夕阳下的奔跑,那是我逝去的青春">
<meta property="og:type" content="website">
<meta property="og:title" content="刘鹏的小站">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="刘鹏的小站">
<meta property="og:description" content="我想起那天夕阳下的奔跑,那是我逝去的青春">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="刘鹏的小站">
<meta name="twitter:description" content="我想起那天夕阳下的奔跑,那是我逝去的青春">
  
    <link rel="alternative" href="/atom.xml" title="刘鹏的小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">刘鹏的小站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">似水流连</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-javascript-继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/16/javascript-继承/" class="article-date">
  <time datetime="2015-06-16T09:41:34.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/javascript-继承/">javascript-继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="理解继承:">理解继承:</h3><p>继承用于在创建子类时，可以调用父类的方法和使用父类定义的变量。 javascript本身没有提供继承的关键字， 而是通过原型链的方式，达到的继承这种效果（即调用父类方法，父类基本变量copy）， 然而javascript 对于父类引用类型的，子类在使用时，使用的是同一份地址，所以如果需求是如此，就没问题， 否则，需要重新在子类中重新定义自己的引用类型，因为javascript没有static 这个含义。</p>
<p>下面会通过一系列演变，最终达到我们所希望的继承效果。</p>
<pre><code><span class="number">1.</span> 原型链
e.g.
<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.property = <span class="literal">true</span>;
    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];
}

SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.property;
};    

<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;
}

SubType.prototype = <span class="keyword">new</span> SuperType();

SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;
};

<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();
alert(instance1.getSuperValue()); 

instance1.colors.push(<span class="string">'black'</span>);
alert(instance1.colors);

<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();
alert(instance2.colors);

问题: 
    <span class="number">1.</span> 父类定义的引用类型变量，子类在创建时会拥有改变量，但此时效果如何在子类上创建一个原型引用属性一样， 而通过子类创建的变量在修改时，会修改到同一份地址，这必然不是我们想要的
    <span class="number">2.</span> 在创建子类同时，不能像父类构造函数传递参数    
</code></pre><p><br></p>
<pre><code><span class="number">2.</span>借用构造函数
e.g.
<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];
    <span class="keyword">this</span>.sayColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.colors;
}

<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span> </span>{
    SuperType.call(<span class="keyword">this</span>,<span class="string">' Nicholas'</span>);
    <span class="keyword">this</span>.age = <span class="number">29</span>;
}

<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();
instance1.colors.push(<span class="string">'black'</span>);
alert(instance1.colors);

<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();
alert(instance2.colors);

alert(instance1.name);
alert(instance1.age);
alert(instance1.sayColor == instance2.sayColor); <span class="comment">//false</span>


优点:
    <span class="number">1.</span>通过 call 改变父类作用域，达到了对于引用类型不共用同一份的问题。

问题:
    <span class="number">1.</span>但无法使用函数复用了，在实例子类时，父类定义的函数也会重新copy
</code></pre><p><br></p>
<pre><code><span class="number">3.</span>组合继承
e.g.
<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];
}

SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    alert(<span class="keyword">this</span>.name);
};

<span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> </span>{
    SuperType.call(<span class="keyword">this</span>,name);
    <span class="keyword">this</span>.age = age;
}

SubType.prototype = <span class="keyword">new</span> SuperType();
SubType.prototype.constructor = SubType();
SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    alert(<span class="keyword">this</span>.age);
};

<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Nicholas'</span>, <span class="number">29</span>);
instance1.colors.push(<span class="string">'black'</span>);
alert(instance1.colors);
instance1.sayName();
instance1.sayAge();

<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Greg'</span>, <span class="number">27</span>);
alert(instance2.colors);
instance2.sayName();
instance2.sayAge();    

优点:
    <span class="number">1.</span>融合原型链和借用构造函数， 堪称完美的方式

问题: 
    <span class="number">1.</span>美中不足是 SuperType() 会调用<span class="number">2</span>次
</code></pre><p><br></p>
<pre><code>4.原型式继承
e.g.
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

var <span class="keyword">person</span> = {
    name:'Nicholas',
    friends: <span class="comment">['Shelby', 'Court', 'Van']</span>,
    sayColor: function() {
        return 'blue';
    }
};

var anotherPerson = object(<span class="keyword">person</span>);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = object(<span class="keyword">person</span>);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');
alert(<span class="keyword">person</span>.friends);
alert(anotherPerson.sayColor == yetAnotherPerson.sayColor);

equals: 
ECMAScript5版本

var <span class="keyword">person</span> = {
    name:'Nicholas',
    friends: <span class="comment">['Shelby', 'Court', 'Van']</span>,
    sayColor: function() {
        return 'blue';
    }
};

var anotherPerson = Object.create(<span class="keyword">person</span>);
anotherPerson.name = 'Greg';
alert(anotherPerson.name);
anotherPerson.friends.push('Rob');

var yetAnotherPerson = Object.create(<span class="keyword">person</span>);
alert(yetAnotherPerson.name);
yetAnotherPerson.name = 'Linda';
alert(yetAnotherPerson.name);

yetAnotherPerson.friends.push('Barbie');
alert(<span class="keyword">person</span>.friends);
alert(anotherPerson.sayColor == yetAnotherPerson.sayColor);


注: 原型式继承也是一种不错的继承方式, 子类变量的修改并不会影响父类的prototype属性，方法也达到了共用, 唯一有点影响的事, 引用类型会始终共享相应的值。
</code></pre><p><br></p>
<pre><code>5. 寄生式继承
e.g.        
function createAnother(original) {
    var clone = Object.create(original);
    clone.sayHi = function() {
        alert(<span class="string">"hi"</span>);
    };
    return clone;
}

var <span class="keyword">person</span> = {
    name: 'Nichoals',
    friends: <span class="comment">['Shelby', 'Court', 'Van']</span>
};

var anotherPerson = createAnother(<span class="keyword">person</span>);
anotherPerson.sayHi();

注: 使用集成式函数，缺点是函数不能复用, 这一点同构造函数类似
</code></pre><p><br></p>
<pre><code><span class="number">6.</span>寄生组合式继承
e.g.
<span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>{
    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}

<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>,<span class="string">' green'</span>];
}

SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    alert(<span class="keyword">this</span>.name);
};

<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>{
    SuperType.call(<span class="keyword">this</span>, name);
    <span class="keyword">this</span>.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    alert(<span class="keyword">this</span>.age);
};

<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Nicholas'</span>, <span class="number">29</span>);
instance1.colors.push(<span class="string">'black'</span>);
alert(instance1.colors);
instance1.sayName();
instance1.sayAge();

<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Greg'</span>, <span class="number">27</span>);
alert(instance2.colors);
instance2.sayName();
instance2.sayAge();

注: 完美
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/16/javascript-继承/" data-id="cickvtj52000p95z9ewzi6vom" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/16/javascript-继承/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript-对象与原型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/16/javascript-对象与原型/" class="article-date">
  <time datetime="2015-06-16T01:26:55.000Z" itemprop="datePublished">2015-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/javascript-对象与原型/">javascript-对象与原型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="理解对象:">理解对象:</h3><p>对象是一种风格， 和其它语言的类的概念相似，类中主要定义了一些基本属性和方法。<br>当类被通过构造使用时，实例对象也会拥有一份新的属性和方法（但此处方法不会被重复创建，还是指向同一个地址）</p>
<p>why？ 方法不需要被重复创建呢？<br>首先，我们理解一个概念，所有语言中最终回转化成汇编执行，即便是动态语言，底层也会有汇编入栈，出栈的这种操作。</p>
<p>当我们通过实例化的对象去调用的一个方法时，我们会取得当前方法的引用地址，并将参数一个个push进去，然后pop出结果即可， 所以说，完全不需要构造两个相同的方法，即使这样做了，也不会有什么影响，浪费内存空间而已。</p>
<p>但变量一般都是copy创建的，我们当然不希望多个实例修改同一个变量，最终得到的变量是一样的吧，如果真的有这样需求，在其它语言中该变量用static定义，而在javascript中，那得用到prototype原型了，说白了，就是只定义一处，大家都使用同一份的方法。</p>
<pre><code><span class="number">1.</span>工厂模式
e.g.
<span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>{
    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        alert(<span class="keyword">this</span>.name);
    };
    <span class="keyword">return</span> o;
}

<span class="keyword">var</span> person1 = createPerson(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Enginner'</span>);
<span class="keyword">var</span> person2 = createPerson(<span class="string">'Grey'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);

问题:
     <span class="number">1.</span> 每次创建方法都是一份新的地址 （重复）
     <span class="number">2.</span> 没有知道该对象的具体类型，也就缺乏了内省机制，好比如说，你问它，你是谁？ 它说不知道。但如果它知道自身是什么，那么那就可以做很多事情了。 python和ruby就完全具备此特性
</code></pre><p><br></p>
<pre><code>2.构造函数模式
e.g. 
function <span class="keyword">Person</span>(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        alert(this.name);
    };
}

var person1 = new <span class="keyword">Person</span>('Nicholas', 29, 'Software Engineer');
var person2 = new <span class="keyword">Person</span>('Greg', 27, 'Doctor');

问题:
    1. 每次创建方法都是一份新的地址 （重复）

注: 此时使用构造函数方式创建对象时，对象内部会有一个constructor（构造属性）指向<span class="keyword">Person</span>，表明时通过谁来创建的。 但constructor并不是实例的属性，它是指向<span class="keyword">Person</span>原型的属性（即共用一份内存地址的属性）
</code></pre><p><br></p>
<pre><code>3.原型模式:
e.g.
function <span class="keyword">Person</span>() {
}

<span class="keyword">Person</span>.prototype.name = 'Nicholas';
<span class="keyword">Person</span>.prototype.age = 29;
<span class="keyword">Person</span>.prototype.job = 'Software Engineer';
<span class="keyword">Person</span>.prototype.sayName = function() {
    alert(this.name);
};

var person1 = new <span class="keyword">Person</span>();
person1.sayName();            //Nicholas

var person2 = new <span class="keyword">Person</span>();
person2.sayName();            //Nicholas
alert(person1.sayName == person2.sayName); // true

好处:
    1.解决了多次创建同一份地址方法

问题: 
    1.无法通过构造进行传参


3.1 字面量方式-1:
e.g.
function <span class="keyword">Person</span>() {
}

<span class="keyword">Person</span>.prototype = {
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName: function() {
        alert(this.name);
    }
}

好处: 
    1.不用每次敲一遍<span class="keyword">Person</span>.prototype

问题:
    1.无法通过构造进行传参
    2.由于重写了默认的prototype, 即通过{}方式重新定义的对象， 因此，constructor属性也就变成了新的constructor属性，（指向了Object构造属性）,不在指向<span class="keyword">Person</span>函数

3.2 字面量方式-2:
e.g.
funciton <span class="keyword">Person</span>() {
}

<span class="keyword">Person</span>.prototype = {
    constructor: <span class="keyword">Person</span>,
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    sayName: function() {
        alert(this.name);
    }
}

好处: 
    1.不用每次敲一遍<span class="keyword">Person</span>.prototype

问题:
    1.无法通过构造进行传参


3.3 字面量方式-3:
e.g.
function <span class="keyword">Person</span>() {
}

<span class="keyword">Person</span>.prototype = {
    constructor: <span class="keyword">Person</span>,
    name: 'Nicholas',
    age: 29,
    job: 'Software Engineer',
    friends: <span class="comment">['Shelby', 'Court']</span>,
    sayName: function() {
        alert(this.name);
    }
}

var person1 = new <span class="keyword">Person</span>();
var person2 = new <span class="keyword">person</span>();

person1.friend.push('Van');
alert(person1.friends);   //'Shelby,Court,Van'
alert(person2.friends);   //'Shelby,Court,Van'
alert(person1.friends === person2.friends); //true


好处: 
    1.不用每次敲一遍<span class="keyword">Person</span>.prototype

问题:
    1.无法通过构造进行传参
    2.由于在原型中使用了引用类型的属性，通过实例修改时，会影响到其它实例。但如果设计目的就是如何，便不再是问题
</code></pre><p><br></p>
<pre><code>4.组合使用构造函数模式和原型模式
e.g.
function <span class="keyword">Person</span>(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = <span class="comment">['Shelby', 'Count']</span>;
}

<span class="keyword">Person</span>.prototype = {
    constructor: <span class="keyword">Person</span>,
    sayName: function() {
        alert(this.name);
    }
}

var person1 = new <span class="keyword">Person</span>('Nicholas', 29, 'Software Engineer');
var person2 = new <span class="keyword">Person</span>('Greg', 27, 'Doctor');

person1.friends.push('Van');
alert(person1.friends);   //'Shelby,Count,Van'
alert(person2.friends);   //'Shelby,Count'
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true

优点：
    1.解决了构造函数传值的问题
    2.使用了简化版的字面量方式
    3.方法在内存中只存在一份
    4.引用类型不再共享一份。

这种模式堪称完美
</code></pre><p><br></p>
<pre><code>5. 动态原型模式
e.g.
function <span class="keyword">Person</span>(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;

    if (typeof this.sayName != 'function') {
        <span class="keyword">Person</span>.prototype.sayName = function() {
            alert(this.name);
        };
    }
}

优点: 
    1. 变量的定义和方法都存在一个函数内，和其它包含class风格的语言更加接近

缺点:
    1. 使用这种方式时， 无法使用字面量方式重写原型方法，如果已经创建了实例的情况下重写原型，就会先切现有实例和新原型之间的联系。（所以说，这种方式不用自面量就好了）

经典模式之一    
</code></pre><p><br></p>
<pre><code>6. 寄生构造函数模式
e.g.
function <span class="keyword">Person</span>(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        alert(this.name);
    };
    return o
}

var friend = new <span class="keyword">Person</span>('Nicholas', 29, 'Software Engineer');
friend.sayName(); //'Nicholas'

注: 对于此模式，目前还未充分认识其价值，或许其中也蕴含宝藏，暂不评论
</code></pre><p><br></p>
<pre><code>7. 稳妥构造函数模式
e.g.
function <span class="keyword">Person</span>(name, age, job) {
    var o = new Object();
    o.sayName = function() {
        alert(name);
    };
    return o;
}

var friend = <span class="keyword">Person</span>('Nicholas', 29, 'Software Enginner');
friend.sayName();

注: 暂不评论
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/16/javascript-对象与原型/" data-id="cickvtj58000t95z9dm84t65r" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/16/javascript-对象与原型/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript-数据属性-访问器属性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/15/javascript-数据属性-访问器属性/" class="article-date">
  <time datetime="2015-06-15T14:45:32.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/javascript-数据属性-访问器属性/">javascript-数据属性&amp;访问器属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作用：主要用于定义变量的权限 （可读，可写，可删除，可枚举）</p>
<p>在其它语言中，比如java， 对于class类中变量需要设置其get， set方法，<br>这样做的目的是出于安全考虑， 仅能调用由class暴露出来的方法。<br></p>
<p>并且可以在方法内对变量进行其它操作，修改其内容或者内部的其它变量。当然，这其实也是非必需的。如swift语言中新出的计算属性这个新词<br></p>
<p>比如lua语言中，并没有要求要对变量设置其get, set属性， 在需要的时候，可以直接修改其内容，只要不进行一些我们自己都不能确定的操作，程序依然是健壮的。当然，这里完全是由人来控制。</p>
<p>object-c语言中， 如果想访问一个受保护的变量， 还可以通过kvc，kvo的方式</p>
<p>总值，javasript的数值属性，访问器属性只是一种对变量进行权限约定和对象的变量进行添加，修改的一种手段， 在合适的时候使用即可</p>
<pre><code>1. 数值属性
    行为特征：
    1.1 <span class="comment">[<span class="comment">[Configurable]</span>]</span>  是否可删除
    1.2 <span class="comment">[<span class="comment">[Enumerable]</span>]</span>    是否可遍历
    1.3 <span class="comment">[<span class="comment">[Writable]</span>]</span>      是否可写
    1.4 <span class="comment">[<span class="comment">[Value]</span>]</span>          属性值， 默认undefined

    e.g.
    var <span class="keyword">person</span> = {};
    Object.defineProperty(<span class="keyword">person</span>, 'name', {
        writable: false,
        value: 'Nicholas'
    });

    alert(<span class="keyword">person</span>.name); //'Nicholas'
    <span class="keyword">person</span>.name = 'Greg';
    alert(<span class="keyword">person</span>.name); //'Nicholas'


2. 访问器属性
    行为特征:
    2.1 <span class="comment">[<span class="comment">[Configurable]</span>]</span>  是否可删除
    2.2 <span class="comment">[<span class="comment">[Enumerable]</span>]</span>    是否可遍历
    2.3 <span class="comment">[<span class="comment">[Get]</span>]</span>              读取属性时调用的方法   默认 underfined
    2.4 <span class="comment">[<span class="comment">[Set]</span>]</span>              写入属性行调用的方法   默认 underfined

    e.g.
    var book = {
        _year: 2004,
        edition: 1
    };

    Object.defineProerty(book, 'year', {
        get: function() {
            return this._year;
        },
        set: function(newValue) {
            if (newValue &gt; 2004) {
                this._year = newValue;
                this._edition += newValue - 2004;
            }
        }
    });

    book.year = 20005; 
    alert(book.edition); //2
</code></pre><p>注： 当通过数据属性或访问器的重新定义变量时， Configurable， Enumerable，Writable 默认值全部都重设为false， 不使用，默认是true</p>
<pre><code>多属性定义方法
<span class="keyword">var</span> book = {};
Object.defineProperties(book, {
    _year: {
        value: <span class="number">2004</span>
    },

    edition: {
        value: <span class="number">1</span>
    },

    year: {
        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> <span class="keyword">this</span>._year;
        },

        <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span> </span>{
            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) {
                <span class="keyword">this</span>._year = newValue;
                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;
            }
        }
    }
});


属性特征读取方式
<span class="keyword">var</span> descriptor = Object.getOwnPropertyDescriptor(book, <span class="string">'_year'</span>);
alert(descriptor.value);        <span class="comment">//2004</span>
alert(descriptor.configurable); <span class="comment">//false</span>
alert(type description.<span class="keyword">get</span>);    <span class="comment">//'undefined'</span>

<span class="keyword">var</span> descriptor = Object.getOwnPropertyDescriptor(book, <span class="string">'year'</span>);
alert(descriptor.value);         <span class="comment">//undefined</span>
alert(descriptor.enumerable);     <span class="comment">//false</span>
alert(<span class="keyword">typeof</span> descriptor.<span class="keyword">get</span>);   <span class="comment">//'function'</span>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/15/javascript-数据属性-访问器属性/" data-id="cickvtj55000r95z9380ikyes" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/15/javascript-数据属性-访问器属性/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript-函数属性callee-caller-apply-call-bind" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/15/javascript-函数属性callee-caller-apply-call-bind/" class="article-date">
  <time datetime="2015-06-15T09:58:34.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/javascript-函数属性callee-caller-apply-call-bind/">javascript-函数属性callee, caller, apply, call, bind</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="callee">callee</h1><pre><code>指向当前拥有arguments对象的函数指针

<span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(num)</span> {</span>
    <span class="keyword">if</span> <span class="params">(num &lt;= <span class="number">1</span>)</span> {
        return <span class="number">1</span>;
    } <span class="keyword">else</span> {
        return num <span class="built_in">*</span> factorial<span class="params">(num - <span class="number">1</span>)</span>;
    }
}

equals:

<span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(num)</span> {</span>
    <span class="keyword">if</span> <span class="params">(num &lt;= <span class="number">1</span>)</span> {
        return <span class="number">1</span>;
    } <span class="keyword">else</span> {
        return num <span class="built_in">*</span> arguments.callee<span class="params">(num - <span class="number">1</span>)</span>;
    }
}


使用 callee 方法具有更好的应用场景。
e.g.
var trueFactorial = factorial;

factorial = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    return <span class="number">0</span>;
};

alert<span class="params">(<span class="literal">true</span>Factorial<span class="params">(<span class="number">5</span>)</span>)</span>;
alert<span class="params">(factorial<span class="params">(<span class="number">5</span>)</span>)</span>;

注: 如果使用 callee参数， 当factorial被指向 别处时， trueFactorial中的callee 也能指向正确的位置。
</code></pre><h1 id="caller">caller</h1><pre><code>指向调用当前函数的函数的引用,  即如果对该引用执行调用方法（），会陷入无限循环当中，然卵用

<span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span> {</span>
    inner<span class="params">()</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span> {</span>
    alert<span class="params">(inner.caller)</span>;
}

outer<span class="params">()</span>;

equals:

<span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span> {</span>
    inner<span class="params">()</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span> {</span>
    alert<span class="params">(arguments.callee.caller)</span>;
}

outer<span class="params">()</span>;


扩展: 
<span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span> {</span>
    inner<span class="params">()</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span> {</span>
    alert<span class="params">(outer.caller)</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> {</span>
    outer<span class="params">()</span>;
}

A<span class="params">()</span>;

当然也可以这么玩。 
</code></pre><h1 id="apply，call">apply，call</h1><pre><code>扩充作用域， 说白了，可以将其他对象注入到函数体内，当在函数内执行<span class="keyword">this</span>. 操作时，操作对象其实是注入的对象。

<span class="number">1.</span>apply 
    参数是可变的。

<span class="keyword">var</span> a = <span class="string">"I'm come from window"</span>;

<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>{
    alert(<span class="keyword">this</span>.a);                 <span class="comment">//"I'm come from window"</span>
    <span class="keyword">return</span> num1 + num2;
}

<span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>{
    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>{
    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);
}

alert(callSum1(<span class="number">10</span>, <span class="number">10</span>));
alert(callSum2(<span class="number">10</span>, <span class="number">10</span>));

此处<span class="keyword">this</span> 传入的是<span class="built_in">window</span>对象

<span class="number">2.</span> call
    参数是固定数值

<span class="keyword">var</span> a = <span class="string">"I'm come from window"</span>;

<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>{
    alert(<span class="keyword">this</span>.a);
    <span class="keyword">return</span> num1 + num2;
} 

<span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>{
    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);
}

alert(callSum(<span class="number">10</span>, <span class="number">10</span>));
</code></pre><h1 id="bind">bind</h1><pre><code>和apply， call类似， 但会创建一个新的函数实例， <span class="keyword">this</span> 指向会通过bind（）传入的值
e.g.    
<span class="built_in">window</span>.color = <span class="string">'red'</span>;
<span class="keyword">var</span> o = { color: <span class="string">'blue'</span> };

<span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>{
    alert(<span class="keyword">this</span>.color);
}

<span class="keyword">var</span> objectSayColor = sayColor.bind(o);
objectSayColor();
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/15/javascript-函数属性callee-caller-apply-call-bind/" data-id="cickvtj5c000v95z9i2q83mfy" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/15/javascript-函数属性callee-caller-apply-call-bind/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript-作用域-变量申明提升" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/15/javascript-作用域-变量申明提升/" class="article-date">
  <time datetime="2015-06-15T05:53:42.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/javascript-作用域-变量申明提升/">javascript-作用域&amp;变量申明提升</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="javascript_没有块级作用域，只有函数作用域">javascript 没有块级作用域，只有函数作用域</h3><pre><code>var <span class="built_in">color</span> = 'red';
<span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> {</span>
    console.<span class="built_in">log</span><span class="params">(color)</span>;  <span class="comment">//undefined</span>
    var <span class="built_in">color</span> = 'blue';
}
A<span class="params">()</span>;

equals:

var <span class="built_in">color</span> = 'red';
<span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> {</span>
    var <span class="built_in">color</span>;
    console.<span class="built_in">log</span><span class="params">(color)</span>;
    <span class="built_in">color</span> = 'blue';
}

A<span class="params">()</span>;

注: 变量<span class="built_in">color</span>在函数题内被重新定义时，会进行申明提升， 提升到函数作用域顶部。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/15/javascript-作用域-变量申明提升/" data-id="cickvtj5h000z95z9idepq9nh" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/15/javascript-作用域-变量申明提升/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript-值传递" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/15/javascript-值传递/" class="article-date">
  <time datetime="2015-06-15T04:14:55.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/javascript-值传递/">javascript-值传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="公理:">公理:</h3><pre><code><span class="number">1.</span> 基础类型变量的直接赋值是值传递
e.g.
var <span class="label">num1</span> = <span class="number">5</span>;
var <span class="label">num2</span> = <span class="label">num1</span>;
<span class="label">num1</span> = <span class="number">10</span>;
alert<span class="comment">(num2)</span>;   <span class="comment">//5</span>
</code></pre><h6 id=""> </h6><pre><code><span class="number">2.</span> 引用类型变量的直接赋值是引用传递
e.g.
<span class="keyword">var</span> obj1 = <span class="keyword">new</span> Oject();
<span class="keyword">var</span> obj2 = obj1;
obj1.name = <span class="string">'Nicholas'</span>;
alert(obj2.name);     <span class="comment">//"Nicholas"</span>
</code></pre><h6 id="-1"> </h6><pre><code>3. javascript 中所有函数的参数都是按值传递的。
e.g.

基础类型:
function addTem(num) {
    num += 10;
    return num;
}

var count = 20;
var result = addTem(count);
alert(count);        //20
alert(result);        //30


对象类型
function setName(obj) {
    obj.name = 'Nicholas';
}

var <span class="keyword">person</span> = new Object();
setName(<span class="keyword">person</span>);
alert(<span class="keyword">person</span>.name);   //'Nicholas'

分析: 
    setName(<span class="keyword">person</span>) 此处时值传递。
    obj对象是<span class="keyword">person</span>的指针地址的copy（栈中的指针地址copy）。 所以说两者还是指向同一份堆地址， 即同一份对象

    当obj.name 改变时，改变的是同一份对象。

    所以说此处的值传递 ＝ 对象引用地址的copy !

在证
function setName(obj) {
    obj.name = 'Nicholas';
    obj = new Object();
    obj.name = 'Greg';
}

var <span class="keyword">person</span> = new Object();
setName(<span class="keyword">person</span>);
alert(<span class="keyword">person</span>.name);      //<span class="string">"Nicholas"</span>

分析：
    当执行obj = new Object()；时， obj会指向堆空间中一份新的object对象

    当执行obj.name = 'Grey'；时，实际操作的是一个新的对象

    而 <span class="keyword">person</span> 还是指向原先在堆中的地址， 
    在setName 方法内，obj.name 将堆中的数值进行了改变，
    此后obj又指向一个新的对象，再次改变其属性时，对原先对象没有影响。
</code></pre><h3 id="注意:">注意:</h3><pre><code>1.当复制保存对象的某个变量时，操作的是对象的引用。
2.当在为对象添加属性时，操作的是实际的对象
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/15/javascript-值传递/" data-id="cickvtj5f000x95z9y0h1r952" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/15/javascript-值传递/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript堆栈浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/15/javascript堆栈浅析/" class="article-date">
  <time datetime="2015-06-15T02:59:30.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/javascript堆栈浅析/">javascript堆栈浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="类型:">类型:</h3><pre><code><span class="bullet">1.    </span>基础类型   
<span class="bullet">2.    </span>引用类型
</code></pre><h3 id="堆空间:">堆空间:</h3><pre><code><span class="number">1</span>.  存储对象 e<span class="class">.g</span>.  <span class="function"><span class="title">Object</span><span class="params">()</span></span>
</code></pre><h3 id="栈空间:">栈空间:</h3><pre><code>1.  存储变量标示符  <span class="keyword">e</span>.<span class="keyword">g</span>.  <span class="keyword">var</span> a;  <span class="keyword">var</span> o = Object()  
    a -&gt; 基础类型变量标示符
    o -&gt; 对象引用变量标示符

2.  存储变量的值    <span class="keyword">e</span>.<span class="keyword">g</span>.  <span class="keyword">var</span> a = 100
    100 -&gt; 基础类型变量的值
</code></pre><p><img src="/img/堆栈分析1.png" alt=""></p>
<p><img src="/img/堆栈分析2.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/15/javascript堆栈浅析/" data-id="cickvtj4v000m95z9kfa2579n" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/15/javascript堆栈浅析/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-人生若只如初见" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/14/人生若只如初见/" class="article-date">
  <time datetime="2015-06-14T11:15:35.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/人生若只如初见/">人生若只如初见</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=314315&auto=0&height=66"></iframe>

<p>人生如梦亦如幻</p>
<p>花开花落，卿为谁待？</p>
<p>流水落花春去也，天上人间。</p>
<p>无情不似多情苦，一寸还成千万缕。</p>
<p>天长地久有时尽，此恨绵绵无绝期。</p>
<p>长于春梦几多时，散似秋云无觅处。</p>
<p>一枝红艳露凝香，云雨巫山枉断肠。</p>
<p>幽兰露，如啼眼。无物结同心，烟花不堪</p>
<p>剪此去经年，应是良辰好景虚设，便纵有，万种风情，更于何人说？</p>
<p>野有蔓草，零露穰穰。有美一人，婉如清扬。邂逅相遇，与子偕臧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/14/人生若只如初见/" data-id="cickvtj4h000c95z9svom4be8" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/14/人生若只如初见/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分手快乐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/14/分手快乐/" class="article-date">
  <time datetime="2015-06-14T10:46:45.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/分手快乐/">分手快乐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=254309&auto=0&height=66"></iframe><br><strong>我无法帮你预言<br><br>委曲求全有没有用<br><br>可是我多么不舍<br><br>朋友爱的那么苦痛<br><br>爱可以不问对错<br><br>至少有喜悦感动<br><br>如果他总为别人撑伞<br><br>你何苦非为他等在雨中<br><br>泡咖啡让你暖手<br><br>想挡挡你心口里的风<br><br>你却想上街走走<br><br>吹吹冷风会清醒的多<br><br>你说你不怕分手<br><br>只有一点遗憾难过<br><br>情人节就要来了<br><br>剩自己一个<br><br>其实爱对了人<br><br>情人节每天都过<br><br>分手快乐<br><br>祝你快乐<br><br>你可以找到更好的<br><br>不想过冬<br><br>厌倦沉重<br><br>就飞去热带的岛屿游泳<br><br>分手快乐<br><br>请你快乐<br><br>挥别错的才能和对的相逢<br><br>离开旧爱<br><br>像坐慢车<br><br>看透彻了心就会是晴朗的<br><br>没人能把谁的幸福没收<br><br>你发誓你会活的有笑容<br><br>你自信时候真的美多了</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/14/分手快乐/" data-id="cickvtj4e000995z9d0ukhrjp" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2015/06/14/分手快乐/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/匆匆那年/">匆匆那年</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/regex/">regex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vagrant/">vagrant</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/匆匆那年/">匆匆那年</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/regex/" style="font-size: 10px;">regex</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/vagrant/" style="font-size: 10px;">vagrant</a> <a href="/tags/匆匆那年/" style="font-size: 10px;">匆匆那年</a> <a href="/tags/并发编程/" style="font-size: 10px;">并发编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/07/27/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2015/07/21/vagrant-开发环境配置/">vagrant 开发环境配置</a>
          </li>
        
          <li>
            <a href="/2015/07/17/golang-RWMutex/">golang-RWMutex</a>
          </li>
        
          <li>
            <a href="/2015/07/14/upstart-命令备忘/">upstart-命令备忘</a>
          </li>
        
          <li>
            <a href="/2015/07/14/docker-命令备忘/">docker-命令备忘</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 刘鹏<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'pengswift';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>